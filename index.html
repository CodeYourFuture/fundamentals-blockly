<html>
  <head>
    <style type="text/css">

      #toc li {
        display:inline-block;
        list-style:none;
        padding:5px;
        border:1px solid black;
        cursor:pointer;
      }

      .blocklyHtml li {
        display:inline-block;
        list-style:none;
        padding:5px;
        cursor:pointer;
        margin:2px;
      }

      .blocklyHtml li.current {
        border-top: 1px solid black;
        border-left: 1px solid black;
        border-right: 1px solid black;
        border-bottom: 1px solid white;
        font-weight: bold;
      }

      .blocklyHtml li.notcurrent {
        border: 1px solid black;
      }

      .blocklyHtml ul {
        margin: 0px;
      }

      .generatedJsTextarea {
        display: none;
      }
    </style>
  </head>
  <body>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <script src="blockly-dom.js"></script>
    <script src="editor.js"></script>
    <div id="toc"></div>
    <div id="exercises">
      <div class="exercise">
      <h2>Introduction</h2>
      <p>In this series of exercises, you will use <em>block-based programming</em>, 
        similar to what you used on code.org, to create javascript that dynamically modifies the html on a web page 
        ("dynamically" means that as the program executes, the initial html will be modified).
      </p>
      <p>In this "Introduction", there is nothing for you to do, only information. You can move to the first exercise whenever you're ready.</p>
      <ul>
        <li>
          Static html can be written in the html textarea ("static" means this is the original state, 
          before the programe).
        </li>
        <li>
          Code to modify the html can be written with blocks.
        </li>
        <li>
          The blocks directly translate to javascript code. You can look at the resulting code in the 
          generated javascript textarea.
        </li>
        <li>
          Clicking "run" will place the html in the space just below the textarea and execute 
          the generated code.
        </li>
        <li>
          These exercises assume you are familiar with using the block-based programming environment, 
          based on having done the code.org exercises. In particular, you should be familiar with if blocks
          and loops.
        </li>
        <li>
          There are some differences with code.org. In particular, you are free to move to the next exercise 
          whenever you feel ready. At some point, grey checkmarks will indicate that your current code doesn't
          appear to solve all the instructions, and green checkmarks will indicate that it does.
        </li>
        <li>
          The end goal is to be able to copy paste the genreated code into a
          single .js file and add it, and the appropriate html, to the an html page 
          created during the fundamentals module.
        </li>
        <li>
          The way the blocks work (and the code they generate) is deliberately similar to what you will learn
          in the upcoming javascript modules. There are also some differences, intended to make it easier as
          a first programming experience.
        </li>
      </ul>
      <h3>Definitions</h3>
      Some of the following may need a definition:
      <ul>
        <li>static vs dynamic</li>
        <li>block based programming</li>
        <li>html elements</li>
        <li>html attributes</li>
        <li>variable</li>
      </ul>
      </div>
      <div class="exercise" id="exercise_change_text">
      <h2>Modifying html dynamically: changing text</h2>
      <script>
      BlocklyTest.registerTest("exercise_change_text", () => {
        let p = BlocklyTest.findElement(["#paragraph", "p"]);
        BlocklyTest.expect(1, "text was changed", p, (p) => {
          return p.innerText.toLowerCase().startsWith("hello world");
        });
      });
    </script>
      <p>
        This exercise introduces the <b>Html blocks</b> to find and modify the text of html elements.
      </p>
        <ol>
            <li>Let's start with a simple piece of html that represents three paragraphs.
                <ol>
                    <li>for example: <code id="start_exercise_change_text">&lt;p&gt;First paragraph.&lt;/p&gt;<br>&lt;p id="paragraph"&gt;Second paragraph&lt;/p&gt;<br>&lt;p&gt;Third paragraph.&lt;/p&gt;</code></li>
                    <li>you can click "run" to see the output</li>
                </ol>
            <li>Let's modify the contents of the second paragraph to read "Hello World!" instead. (This is typically the first programme that every programmer writes in any new language, so we'll honour tradition and do that here.)</li>
                <ol>
                    <li>Add an <span class="blockname">"at the start"</span> block</li>
                    <li>Inside this block, add a <span class="blockname">"find the element using css selector"</span> block using the css selector for the id of the second paragraph &lt;p&gt; element (<code>#paragraph</code>)</li>
                    <li>Inside this block, add a <span class="blockname">"set the text content to"</span> block</li>
                    <li>Set the value for the text of this block :<code>Hello World!</code></li>
                    <li id="exercise_change_text_1">Click "run" to check the content of the second paragraph has changed.</li>
                </ol>
            </li>
        </ol>
      </div>

      <div class="exercise" id="exercise_set_colours">
      <h2>Modifying html dynamically: setting colours</h2>
      <script>
      BlocklyTest.registerTest("exercise_set_colours", () => {
        let firstLi = BlocklyTest.findElement(["#banana", "li:nth-child(1)"]);
        let startColor = window.getComputedStyle(firstLi).color;
        BlocklyTest.expect(1, "colour was changed", firstLi, (li) => {
          return window.getComputedStyle(li).color != startColor;
        })
        let startBackgroundColor = window.getComputedStyle(firstLi).backgroundColor;
        BlocklyTest.expect(2, "background colour was changed", firstLi, (li) => {
          return window.getComputedStyle(li).backgroundColor != startBackgroundColor;
        })
        if (firstLi) {
          BlocklyTest.expect(3, "all colours are changed", firstLi.parentElement, (ul) => {
            return ul.children.length > 1 && Array.from(ul.children).every((li) => window.getComputedStyle(li).color != startColor);
          })
        }
      });
    </script>
      <p>
        Not only can we modify the contents of html elements, we can also change their properties, such as their colour. Different kinds of <b>Values blocks</b> provide ways of setting texts, numbers and colours.
      </p>
        <ol>
            <li>Let's start with an html list of our favourite fruit in the "Static html" 
                <ol>
                    <li>each html list item (<code>&lt;li&gt;</code>) has a different id attribute so that we can refer to it using a css selector</li>
                    <li>for example: <code id="start_exercise_set_colours">&lt;ul&gt;<br>&lt;li id="banana"&gt;Banana&lt;/li&gt;<br>&lt;li id="orange"&gt;Orange&lt;/li&gt;<br>&lt;/ul&gt;</code></li>
                    <li>you can click "run" to see the output</li>
                </ol>
            <li>Color the banana yellow</li>
                <ol>
                    <li>Add an <span class="blockname">"at the start"</span> block</li>
                    <li>Inside this block, add a <span class="blockname">"find the element using css selector"</span> block using the id selector for the &lt;li&gt; element for Banana (<code>#banana</code>)</li>
                    <li id="exercise_set_colours_1">Inside this block, add a <span class="blockname">set the attribute"</span>" block, pick "color" and set the value to any yellow colour using the <span class="blockname">colour picker</span> (you can find a color picker block in the "Values" menu).</li>
                    <li id="exercise_set_colours_2">The colour for a banana is probably not easy to see against a white background. Add a second <span class="blockname">"set the attribute"</span> block and set a dark color for the background.</li>
                    <li>Click "run" to check the output looks like
                        <ul style="background-color: azure;">
                            <li style="color:rgb(233, 233, 22);background-color: darkgrey;">Banana</li>
                            <li>Orange</li>
                        </ul>
                    </li>
                </ol>
            </li>
            <li id="exercise_set_colours_3">Repeat the process above to colour each of the fruit (hint: you can add multiple <span class="blockname">"find the element using css selector"</span> blocks one after the other). You can also change the background color if you like</li> 
        </ol>
      </div>
      <div class="exercise" id="exercise_add_fruit">
      <h2>Creating html dynamically: lists of fruit</h2>
      <script>
        BlocklyTest.registerTest("exercise_add_fruit", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let startLiCount = 0;
          if (ul) {
            startLiCount = ul.children.length;
          }
          BlocklyTest.expect(1, "Banana is added dynamically as the second item", ul, (ul) => {
            if (startLiCount !== 2 && !ul.children.length == 2) return false;
            return ul.children.item(1).innerText == "Banana" || ul.children.item(1).innerText == "banana" 
          })
          BlocklyTest.expect(2, "There are at least 4 items", ul, (ul) => {
            return ul.children.length >= 4
          })
        });
      </script>
      <p>
        Not only can we modify existing html elements, we can also create new ones and set their text and properties.
      </p>
        <ol>
            <li>Let's start with an html list with a single apple in the "Static html" 
                <ol>
                    <li>Note the list has an id ("list") so that we can refer to it using a css selector.</li>
                    <li>for example: <code id="start_exercise_add_fruit">&lt;ul id="list"&gt;<br>&lt;li&gt;Apple&lt;/li&gt;<br>&lt;/ul&gt;</code></li>
                </ol>
            <li>Add one more fruit dynamically</li>
                <ol>
                    <li>Add an <span class="blockname">"at the start"</span> block</li>
                    <li>Inside this block, add a <span class="blockname">"find the element using css selector"</span> block using the id for the ul element (<code>#list</code>)</li>
                    <li>Inside this block, add a <span class="blockname">"create a new ... element"</span> block and select "&lt;li&gt;"</li>
                    <li>Inside this block, add a <span class="blockname">"set the text content"</span> block and set the value to "Banana"</li>
                    <li id="exercise_add_fruit_1">Click "run" to check the output looks like
                        <ul style="background-color: azure;">
                            <li>Apple</li>
                            <li>Banana</li>
                        </ul>
                    </li>
                </ol>
            </li>
            <li id="exercise_add_fruit_2">Repeat the process above to add two more of your favourite fruit (hint: you can add multiple <span class="blockname">"create a new ... element"</span> blocks one after the other)</li> 
        </ol>
      </div>
      <div class="exercise" id="exercise_list_links">
      <h2>Creating html dynamically: lists of links</h2>
      <script>
        BlocklyTest.registerTest("exercise_list_links", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let startLiCount = 0;
          if (ul) {
            startLiCount = ul.children.length;
          }
          BlocklyTest.expect(1, "There are 3 links with href attributes", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return startLiCount != 3 && lis.length == 3 && lis.every((li) => li.querySelector("a[href]") && li.querySelector("a[href]").innerText);
          })
        });
      </script>
      <p>
        This exercise consolidates the use of the blocks we learned about in the previous exercises.
      </p>
        <ol>
            <li>Start with an empty unordered html list (<code id="start_exercise_list_links">&lt;ul id="list"&gt;&lt;/ul&gt;</code>) in the static html.
            <li>Dynamically add your favourite links to the html list</li>
                <ol>
                    <li>Find the urls of your three favourite websites (they look something like: <code>http://www.codeyourfuture.io</code>)</li>
                    <li>Use the blocks we have seen so far ("at the start", "find the element using css selector", "create a new ... element", "set the attribute", "set the text content", and the Values blocks)</li>
                    <li>Hint: you will need to create an <code>&lt;a&gt;</code> inside of each <code>&lt;li&gt;</code></li>
                    <li>Hint: remember that to set the target of an <code>&lt;a&gt;</code> you can use the <code>&lt;href&gt;</code> attribute. Without this attribute, your link will not <i>look</i> like a link</li>
                    <li>Note about problem solving: The less blocks you add before clicking "run", the more you can be sure the code you have so far does what you expect. How could you break your solution down into small chunks where you can test at each stage by clicking "run"?</li>
                    <li id="exercise_list_links_1">Click "run" to check the output looks something like
                        <ul style="background-color: azure;">
                            <li><a href="http://www.codeyourfuture.io">Code your future</a></li>
                            <li><a href="http://www.google.com">Google</a></li>
                            <li><a href="http://news.bbc.co.uk">BBC News</a></li>
                        </ul>
                    </li>
                </ol>
            </li> 
        </ol>
      </div>
      <div class="exercise" id="exercise_button_add">
      <h2>Buttons and clicks: A button to add apples</h2>
      <script>
        BlocklyTest.registerTest("exercise_button_add", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let button = BlocklyTest.findElement(["#button", "button:nth-of-type(1)"]);
          let button2 = BlocklyTest.findElement(["#button2", "button:nth-of-type(2)"]);

          BlocklyTest.expectAfterClick(1, "The button adds an apple", button, 
          () => {
            let count = ul ? ul.children.length : 0;
            return count;
          },
          (countBefore, countAfter) => {
            let addsExactlyOneChild = countBefore + 1 == countAfter
            var lastLi = ul.lastChild;
            return (addsExactlyOneChild && lastLi.innerText.toLowerCase() == "apple");
          });

          BlocklyTest.expectAfterClick(2, "The second button removes all apples", button2, 
          () => {
            let count = ul ? ul.children.length : 0;
            return count;
          },
          (countBefore, countAfter) => countBefore > 0 && countAfter == 0);
        });
      </script>
      <p>
        A lot of javascript is run responsively to the user interacting with the page (clicking, scrolling, etc.). Let's make it so every time we (as a "user") click on an "add an apple" button, it adds an apple to the list.
      </p>
        <ol>
            <li>Start with an empty unordered html list (<code>&lt;ul&gt;</code>) and a button to add apples to the list (<code>&lt;button&gt;</code>) in the static html.
                <ol>
                    <li>for example: <code id="start_exercise_button_add">&lt;ul id="list"&gt;&lt;/ul&gt;<br>&lt;button id="button"&gt;add an apple&lt;/button&gt;</code></li>
                </ol>
            <li>When we click on the "add an apple" button, let's add an apple to the list</li>
                <ol>
                    <li>Add a <span class="blockname">"when the element with id ... is clicked"</span> block (it doesn't need to be connected to any other blocks)</li>
                    <li id="exercise_button_add_1">Inside this block, add the blocks necessary to find the "list" element, create a new "li" element and set the content to "apple" (you know how to do this from previous exercises)</li>
                </ol>
            </li> 
            <li id="exercise_button_add_2">Can you add a second button (in the static html, with a different id) that removes all the apples (you can do this by using the <span class="blockname">"remove the contents of the element"</span> block).              
            </li>
        </ol>
      </div>
      <div class="exercise" id="exercise_button_consolidation">
      <h2>Buttons and clicks consolidation</h2>
      <p>
        Anything that we could do previously as soon as run is clicked, we can now do as a response to clicking the buttons in our generated html.
      </p>
        <ol>
            <li id="exercise_button_consolidation_1">Can you create two buttons that respectively change an html list to "day mode" (dark text on a light background) and "night mode" (light text on a dark background)</li>
            <li id="exercise_button_consolidation_2">Can you create a button that changes colour when it is clicked (note: in the interest of simplifying these exercises, this is one block more complicated than it would be in regular javascript)?
            <li id="exercise_button_consolidation_3">Can you create an image that changes when it is clicked?</li>
        </ol>
      </div>
      <div class="exercise" id="exercise_arrays">
      <h2>Arrays and loops</h2>
      <script>
        BlocklyTest.registerTest("exercise_arrays", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = BlocklyTest.findArrayValues(); // first of the arrays is the one we want

          BlocklyTest.expect(1, "One element is shown", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return lis.length > 0 && lis[0].innerText == list[0];
          });

          BlocklyTest.expect(2, "As many elements are shown as there are items in the array", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == list.length;
          });

          BlocklyTest.expect(3, "All the elements in the array (at least 3) are in the html list", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return list.length >= 3 && lis.length == list.length && lis.every((li, index) => li.innerText == list[index]);
          });

          BlocklyTest.expect(4, "All the elements in the array (at least 4) are in the html list", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return list.length >= 4 && lis.length == list.length && lis.every((li, index) => li.innerText == list[index]);
          });
        });
      </script>
      <p>In this series of exercises, we have so far used one <span class="blockname">"create a new ... element"</span> for each <code>&lt;li&gt;</code> we want to create. 
        We will now introduce a data structure called an <b>Array</b>, that represents of list of data (typically numbers or texts) in javascript. 
        They can be created and used from the "Arrays" menu. We often use an array when we want to do the same thing with each element in an array (for example, create a <code>&lt;li&gt;</code>).
      </p>
      <ol>
          <li>Start with an empty unordered html list with the id "list" (<code id="start_exercise_arrays">&lt;ul id="list"&gt;&lt;/ul&gt;</code>) in the static html.</li>
          <li>Add an <span class="blockname">"at the start"</span> block"</li>
          <li>We'll now create a array of fruits and assign it to a variable <ol>
              <li>From the "Arrays" menu, add a <span class="blockname">"Set ... to, create array with" block to the <span class="blockname">"at the start"</span> block</li>
              <li>Rename the variable <span class="variablename">"array"</span> to "fruits"</li>
              <li>Add at least 3 fruit text values to this array</li>
              <li>Note: You can click on the gear menu to add and remove slots for values</li>
          </ol></li>
          <li>Let's do the first steps to convert the first entry in this array into <code>&lt;li&gt;</code><ol>
              <li>You already know how to do most of the steps (find the element with id list, create an li, set its text content)</li>
              <li>The thing we will do differently is to set the text content to a <span class="blockname">get the first item from the array</span> block, selecting the "fruits" array in the dropdown.</li>
              <li id="exercise_arrays_1">Click "run" to check you are displaying a list with one fruit</li>
          </ol></li>
          <li>Let's use this same code to show all the fruits<ol>
              <li>At the beginning of the <span class="blockname">"find the element using css selector"</span> block, insert a <span class="blockname">"for each item in array"</span> block. Select the fruits array in the dropdown.</li>
              <li>Move all of the <span class="blockname">"create a new ... element"</span> blok inside the for <span class="blockname">"for each item in array"</span> block</li>
              <li id="exercise_arrays_2">As you can see by clicking "run", you now have a list with multiple items - but they are all the first item in the array</li>
              <li>Inside the loop, you have a variable available called <span class="variablename">"item"</span>. Each time through the loop, this variable will take on the value of the next fruit in the array</li>
              <li>Replace the <span class="blockname">get the first item from the array</span> block with a "item" variable block (you can find it in the Variables menu)</li>
              <li id="exercise_arrays_3">Check by clicking run that you now have a list with each item of fruit in your array.</li>
              <li>If you have an array called "fruits", it's good practice to rename the loop "item" variable to "fruit".</li>
          </ol></li>
          <li id="exercise_arrays_4">Add another fruit to your array and check that all your fruits are still shown.</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_list_loops">
      <h2>Lists and loops</h2>
      <script>
        BlocklyTest.registerTest("exercise_list_loops", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = BlocklyTest.findArrayValues(); // first of the arrays is the one we want

          BlocklyTest.expect(1, "All the elements in the list are in the html list. There are at least 4 elements", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return lis.length>=4 && lis.length == list.length && lis.every((li, index) => li.innerText == list[index]);
          });
        });
      </script>
      <p>So far we have worked with a list where we knew exactly the number of items there would be. But what happens if that number is changeable?</p>
      <ol>
          <li>Starting with recreating the result of the previous exercise, then add a new fruit item to your list. Does it display if you click "run"?</li>
          <li>Currently, you have just as many "create a new ... element" blocks as there are items in the list, instead, we are going to use the "list ... has current element" block, combined with a loop</li>
          <li>If you use enough "select next item for list" blocks, you run off the end and the current item no longer exists. In this case, "list ... has current element" returns the value false</li>
          <li>We can use this as the condition in a "repeat while" loop <ol>
              <li>Add a "repeat while" block just before your first "create a new ... element"</li>
              <li>Set the condition value "list ... has current element" (remember to select "fruits" in the dropdown)</li>
              <li>Inside the loop, add the blocks to create a new <code>&lt;li&gt;</code> and set the contents to "get current item from list"</li>
              <li>Inside the loop, add the block to select the next item in the list</li>
              <li id="exercise_list_loops_1">Check that all your fruit are now displaying</li>
              <li>Check that this is still true if you add and remove fruit from the fruits list</li>
          </ol></li>
      </ol>
      </div>
      <div class="exercise" id="exercise_list_loops_more">
      <h2>Loops, and lists: more fun with fruit</h2>
      <script>
        BlocklyTest.registerTest("exercise_list_loops_more", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = BlocklyTest.findArrayValues(); // first of the arrays is the one we want
          let listReversed = list.slice().reverse();
          let listApplesFirst = [];
          let lastAppleIndex = -1;
          list.filter((value, index) => {
            if (value.toLowerCase()=="apple") {
              lastAppleIndex = index;
              return true;
            }
            return false;
          }).forEach((apple) => listApplesFirst.push(apple));
          if (lastAppleIndex == listApplesFirst.length-1) {
            // there isn't an out of order apple -> force to fail
            listApplesFirst.push("");
          }
          list.filter((value) => value.toLowerCase()!="apple").forEach((notApple) => listApplesFirst.push(notApple));

          BlocklyTest.expect(1, "All the elements in the list are in the html list in reverse order", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == listReversed.length && lis.every((li, index) => li.innerText == listReversed[index]);
          });

          BlocklyTest.expect(2, "All the elements in the list are in the html list with apples first", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == listApplesFirst.length && lis.every((li, index) => li.innerText == listApplesFirst[index]);
          });
        });
      </script>
      <p>Although we can convert a list directly into an html list, we can also generate more than one output with the same list.</p>
      <ol>
          <li id="exercise_list_loops_more_1">Using the blocks we have seen so far (with slight modifications), create an html list with the fruit in reverse order</li>
          <li id="exercise_list_loops_more_2">Using the blocks we have seen so far and the if block, create an html list of the fruit with all the apples first (they are my favourite) and the other fruit after (add several apples at the beginning, middle and end of your list to check it works)</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_train_stops">
      <h2>Listing train stops</h2>
      <script>
        BlocklyTest.registerTest("exercise_train_stops", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = ["Glasgow Queen Street", "Falkirk High", "Haymarket", "Edinburgh Waverly"];
          let reversedList = list.slice().reverse();
          let thereAndBackList = list.slice();
          thereAndBackList.pop();
          thereAndBackList = thereAndBackList.concat(reversedList); 
          
          BlocklyTest.expect(1, "Stops are in order from Glasgow to Edinburgh", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == list.length && lis.every((li, index) => li.innerText == list[index]);
          });

          BlocklyTest.expect(2, "Stops are in order from Edinburgh to Glasgow", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == reversedList.length && lis.every((li, index) => li.innerText == reversedList[index]);
          });

          BlocklyTest.expect(3, "Stops are in order from Glasgow to Edinburgh and back. Only show Edinburgh once", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == thereAndBackList.length && lis.every((li, index) => li.innerText == thereAndBackList[index]);
          });
        });
      </script>
      <p>The fast train between Glasgow and Edinburgh stops at Falkirk High and Haymarket. Let's display some html lists of stops</p>
      <ol>
          <li>Create a list named "stops" to represent all the stops, with the values: Glasgow Queen Street, Falkirk High, Haymarket, Edinburgh Waverly. Do the following tasks without changing the values in this list</li>
          <li id="exercise_train_stops_1">Display the html list of all the stops between Glasgow and Edinburgh
              <ul style="background-color: azure;">
                <li>Glasgow Queen Street</li>
                <li>Falkirk High</li>
                <li>Haymarket</li>
                <li>Edinburgh Waverly</li>
              </ul>
          </li>
          <li id="exercise_train_stops_2">Display the html list of all the stops between Edinburgh and Glasgow
              <ul style="background-color: azure;">
                <li>Edinburgh Waverly</li>
                <li>Haymarket</li>
                <li>Falkirk High</li>
                <li>Glasgow Queen Street</li>
              </ul>
          </li>
          <li id="exercise_train_stops_3">Display the html list of all the stops on a return journey from Glasgow to Edinburgh and back
              <ul style="background-color: azure;">
                <li>Glasgow Queen Street</li>
                <li>Falkirk High</li>
                <li>Haymarket</li>
                <li>Edinburgh Waverly</li>
                <li>Haymarket</li>
                <li>Falkirk High</li>
                <li>Glasgow Queen Street</li>
              </ul>
          </li>
      </ol>
      </div>
      <div class="exercise" id="exercise_list_consolidation">
      <h2>List consolidation</h2>
      <p>Repeat the exercise to show a list of your favourite links. Use a loop so that there are only two "create a ... element" blocks (one for the &lt;li&gt;, one for the &lt;a&gt;). Outline what your solution needs to look like, and implement it step by step, clicking "run" at each iteration to check your work</p>
      </div>
      <div class="exercise" id="exercise_lists_buttons">
      <h2>Lists and buttons</h2>
      <script>
        BlocklyTest.registerTest("exercise_lists_buttons", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let button = BlocklyTest.findElement(["#button", "button"]);
          let listToBeRevealed = BlocklyTest.findArrayValues(); // first of the arrays is the one we want

          BlocklyTest.expectAfterClick(1, "Each click of the button reveals a fruit", button, 
          () => {
            let count = ul ? ul.children.length : 0;
            return count;
          },
          (countBefore, countAfter) => {
            let addsExactlyOneChild = countBefore + 1 == countAfter;
            if (addsExactlyOneChild) {
              let lastLi = ul.lastChild;
              if (lastLi && lastLi.innerText == listToBeRevealed[0]) {
                listToBeRevealed.shift();
              }
            }
            return listToBeRevealed.length == 0;
          });
        });
      </script>
      <p>One way to do something with all the items in a list is to use a loop. Instead, let's look at each item one by one as the user clicks on a button</p>
      <ol>
          <li>Create an empty unordered html list (as usual) and a "reveal next fruit" button (<code id="start_exercise_lists_buttons">&lt;ul id="list"&gt;&lt;/ul&gt;&lt;button id="button"&gt;reveal next fruit&lt;/button&gt;</code>)</li>
          <li>Create a list of your favourite fruit inside an <span class="blockname">"at the start"</span> block</li>
          <li id="exercise_lists_buttons_1">Each time the user clicks on the button, the next fruit should be added to the list (yes, you can do things with the list of fruit from the blocks in a <span class="blockname">"when the element with id ... is clicked"</span>)</li>
          <li>As a stretch goal, when there are no more fruits to be revealed, clicking the button should do nothing - or the button should no longer be visible</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_story_book">
      <h2>Create a story book</h2>
      <p>The great thing about story books is that you never know what will happen when you turn the page!</p>
      <ol>
          <li>Create a simple story book "experience" where you click on a button and something new happens</li>
          <li>Make the story a bit more complicated. Maybe the user has choices? Maybe an image appears at the end?</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_image_carousel">
      <h2>Build an image carousel</h2>
      <p>
        An image carousel has an image with two buttons ("previous" and "next")
        that allow the user to cycle through a list of images.
      </p>
      <ul>
        <li>
          A list of at least 3 image urls should be defined in an array (you can
          use public urls from stock photograph websites, or copy the image link from a google search result)
        </li>
        <li>
          Clicking on the "previous" button should show the previous image
        </li>
        <li>Clicking on the "next" button should show the next image</li>
        <li>
          Stretch goal: if clicking next or previous would take us before the
          first item or after the last, cycle round to the last/first item
          instead
        </li>
      </ul>
      <p>
        You should first break down this problem into steps, then outline how
        each step will probably be solved (and how you can test that it does what you think it does), before creating any blocks
      </p>
    </div>
    <div class="exercise" id="exercise_projects">
      <h2>Some more "projects"</h2>
      <p>Here are some additional ideas of projects that can be accomplished with the current blocks 
        (some newer blocks haven't been properly introduced yet) and might be suitable/adaptable as 
        landing page enhancements. They all fit generally into the "add some button or event handlers 
        that add or modify some html" category.
      </p>
      <ul>
        <li>Shopping cart<ol>
          <li>Create a list of products.</li>
          <li>Display each product in an html list with a "add to shopping cart" button next to it</li>
          <li>When the button is clicked, add the product to a separate html list that represents the current shopping cart</li>
        </ol></li>
        <li>List with a hidden 2nd level<ol>
          <li>Create an html list with a second list inside each li (maybe a list of folders and the files in each folder?)</li>
          <li>Hide the inner lists</li>
          <li>Clicking the first level item toggles the visibility of the inner list (if it's hidden, show it, if it's visible, hide it)</li>
        </ol></li>
        <li>Paginated list<ol>
          <li>Create a list of 9 items (maybe there are 9 results of a search?)</li>
          <li>Display the first 3 elements and buttons below marked "previous" and "next"</li>
          <li>Clicking next should show the next 3 elements (if there are any left)</li>
          <li>Clicking next should show the next 3 elements (if there are any)</li>
          <li>Stretch goal: don't show previous/next if there are no previous/next items</li>
          <li>Stretch goal: what happens if there are 8 items in the list</li>
          <li>Stretch goal: display the current page/total (e.g. "page 2/3") (note this probably requires string concatenation operations in the toolbox that aren't there yet)</li>
        </ol></li>
        <li>Hamburger menu<ol>
          <li>Can be vaguely inspired by e.g. https://dev.to/devggaurav/let-s-build-a-responsive-navbar-and-hamburger-menu-using-html-css-and-javascript-4gci</li>
          <li>Display an ul of nav links as a "closed" hamburger</li>
          <li>Clicking on the hamburger makes the ul visible</li>
          <li>Clicking on the hamburger transforms the hamburger into an X</li>
          <li>Clicking on the X makes the ul invisible (and shows the hamburger)</li>
          <li>Clicking on any link makes the ul invisible (and shows the hamburger)</li>
        </ol></li>
        <li>Create a check list<ol>
          <li>Display a list of todo items</li>
          <li>When each item is clicked, mark it in some way (strike through, invisible)</li>
          <li>Note: this is basically a variant of the shopping cart</li>
        </ol></li>
        <li>Create a todo list<ol>
          <li>Display an input and an "add todo" button (currently the input and means of accessing the input don't exist, so would have to add some blocks)</li>
          <li>When the "add todo" is clicked, add the item to an html list</li>
          <li>Stretch goal: combine with the exercise above</li>
        </ol></li>
      </ul>
    </div>
    <xml id="toolbox" style="display: none">
      <category name="Loops" colour="120">
        <block type="controls_whileUntil"></block>
        <block type="arrays_forEach">
          <field name="VAR">item</field>
          </value>
          <value name="LIST">
            <block type="variables_get">
                <field name="VAR">array</field>
            </block>
          </value>
        </block>
        <block type="controls_for"></block>
      </category>
      <category name="Logic" colour="210">
        <block type="controls_if"></block>
        <block type="logic_negate"></block>
        <block type="logic_compare"></block>
      </category>
      <category name="Values" colour='%{BKY_TEXTS_HUE}'>
        <block type="math_number"></block>
        <block type="text"></block>
        <block type="colour_picker"></block>
        <block type="logic_boolean"></block>
      </category>
      <category name="Html" colour="%{BKY_COLOUR_HUE}">
        <block type="on_start"></block>
        <block type="element_clicked"></block>
        <block type="with_element_by_selector"></block>
        <block type="add_element"></block>
        <block type="set_content">
          <value name="VALUE">
            <shadow type="text"> </shadow>
          </value>
        </block>
        <block type="set_attribute"></block>
        <block type="remove_contents"></block>
        <block type="element_clicked_current"></block>
        <block type="with_elements_by_selector"></block>
      </category>
      <category name="Arrays" colour="%{BKY_LISTS_HUE}"" >
        <block type="variables_set">
          <field name="VAR">array</field>
          <value name="VALUE">
            <block type="lists_create_with">
              <!--
              would be nice but the shadow blocks don't know what to do with themselves when the list
              is mutated -> https://github.com/google/blockly/issues/4939
              <value name="ADD0">
                <shadow type="text"> </shadow>
              </value>
              <value name="ADD1">
                <shadow type="text"> </shadow>
              </value>
              <value name="ADD2">
                <shadow type="text"> </shadow>
              </value>-->
            </block>
          </value>
        </block>
        <block type="arrays_getFirst">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">array</field>
            </block>
          </value>
        </block>
        <block type="arrays_push">
          <value name="LIST">
            <block type="variables_get">
                <field name="VAR">array</field>
            </block>
          </value>
        </block>
        <block type="lists_isEmpty">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">array</field>
            </block>
          </value>
        </block>
        <block type="arrays_forEach">
          <field name="VAR">item</field>
          </value>
          <value name="LIST">
            <block type="variables_get">
                <field name="VAR">array</field>
            </block>
          </value>
        </block>
      </category>
      <!--<category name="Lists" colour="%{BKY_LISTS_HUE}"" >
        <block type="variables_set">
          <field name="VAR">list</field>
          <value name="VALUE">
            <block type="linked_lists_create_with"> </block>
          </value>
        </block>
        <block type="linked_lists_get_current">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_set_current">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_has_current">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_has_next">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_has_previous">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
      </category>-->
      <category name="Variables" colour="330" custom="VARIABLE"></category>
      <category name="Functions" colour="290" custom="PROCEDURE"></category>
    </xml>
    <script src="exercises.js"></script>
  </body>
</html>
