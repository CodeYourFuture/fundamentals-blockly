<html>
  <head>
    <style type="text/css">

      #toc li {
        display:inline-block;
        list-style:none;
        padding:5px;
        border:1px solid black;
        cursor:pointer;
      }

      .blocklyHtml li {
        display:inline-block;
        list-style:none;
        padding:5px;
        cursor:pointer;
        margin:2px;
      }

      .blocklyHtml li.current {
        border-top: 1px solid black;
        border-left: 1px solid black;
        border-right: 1px solid black;
        border-bottom: 1px solid white;
        font-weight: bold;
      }

      .blocklyHtml li.notcurrent {
        border: 1px solid black;
      }

      .blocklyHtml ul {
        margin: 0px;
      }

      .generatedJsTextarea {
        display: none;
      }
    </style>
  </head>
  <body>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <script src="blockly-dom.js"></script>
    <script src="editor.js"></script>
    <div id="toc"></div>
    <div id="exercises">
      <div class="exercise">
      <h2>Introduction</h2>
      <p>This is only information (not yet very good information). There is nothing for you to do. You can move straight to the first exercise ("Modifying html dynamically: setting colours").</p>
      <ul>
        <li>Static html can be written in the html textarea</li>
        <li>Any dynamic html or code can be written in blockly</li>
        <li>
          Clicking "run" will place the html in the browser below and then execute
          the blockly code
        </li>
        <li>
          These exercises are intended as a progression during a revised version
          of fundamentals after having completed code.org blockly exercises
        </li>
        <li>
          The end goal is to be able to copy paste the genreated code into a
          single .js file and add it, and the appropriate html, to the landing
          page created during the application process
        </li>
        <li>
          All these exercises build up to a) understanding how to use the
          blockly blocks in the toolbox b) be able to break down solving the
          final problem into steps
        </li>
        <li>
          Long term, each exercise would maybe have some html pre-created and a
          toolbox with only the blocks that are currently known/being introduced
        </li>
        <li>The list API is deliberately different from usual javascript arrays (is it simpler though?)</li>
        <li>The HTML/DOM API is deliberately different from the dom (more embedding, less variables)</li>
      </ul>
      </div>
      <div class="exercise" id="exercise_set_colours">
      <h2>Modifying html dynamically: setting colours</h2>
      <script>
      BlocklyTest.registerTest("exercise_set_colours", () => {
        let firstLi = BlocklyTest.findElement(["#banana", "li:nth-child(1)"]);
        let startColor = window.getComputedStyle(firstLi).color;
        BlocklyTest.expect(1, "colour was changed", firstLi, (li) => {
          return window.getComputedStyle(li).color != startColor;
        })
        let startBackgroundColor = window.getComputedStyle(firstLi).backgroundColor;
        BlocklyTest.expect(2, "background colour was changed", firstLi, (li) => {
          return window.getComputedStyle(li).backgroundColor != startBackgroundColor;
        })
        if (firstLi) {
          BlocklyTest.expect(3, "all colours are changed", firstLi.parentElement, (ul) => {
            return ul.children.length > 1 && Array.from(ul.children).every((li) => window.getComputedStyle(li).color != startColor);
          })
        }
      });
    </script>
      <p>
        This exercise introduces the <b>Html blocks</b> to find html elements and modify their attributes.
      </p>
        <ol>
            <li>Let's start with an html list of our favourite fruit in the "Static html" 
                <ol>
                    <li>each html list item (<code>&lt;li&gt;</code>) has a different id attribute so that we can refer to it from Blockly</li>
                    <li>for example: <code id="start_exercise_set_colours">&lt;ul&gt;&lt;li id="banana"&gt;Banana&lt;/li&gt;&lt;li id="orange"&gt;Orange&lt;/li&gt;&lt;/ul&gt;</code></li>
                    <li>you can click "run" to see the output</li>
                </ol>
            <li>Color the banana yellow</li>
                <ol>
                    <li>Add an "at the start" block</li>
                    <li>Inside this block, add a "find the element using css selector" block using the selector for the &lt;li&gt; element for Banana (<code>#banana</code>)</li>
                    <li id="exercise_set_colours_1">Inside this block, add a "set the attribute" block, pick "color" and set the value to an appropriate colour using the colour picker</li>
                    <li id="exercise_set_colours_2">The colour for a banana is probably not easy to see against a white background. Add a second "set the attribute" block and set a dark color for the background</li>
                    <li>Click "run" to check the output looks like
                        <ul style="background-color: azure;">
                            <li style="color:rgb(233, 233, 22);background-color: darkgrey;">Banana</li>
                            <li>Orange</li>
                        </ul>
                    </li>
                </ol>
            </li>
            <li id="exercise_set_colours_3">Repeat the process above to colour each of the fruit (hint: you can add multiple "find the element using css selector" blocks one after the other). You can also change the background color if you like</li> 
        </ol>
      </div>
      <div class="exercise" id="exercise_add_fruit">
      <h2>Creating html dynamically: lists of fruit</h2>
      <script>
        BlocklyTest.registerTest("exercise_add_fruit", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let startLiCount = 0;
          if (ul) {
            startLiCount = ul.children.length;
          }
          BlocklyTest.expect(1, "Banana is added dynamically as the second item", ul, (ul) => {
            if (startLiCount !== 2 && !ul.children.length == 2) return false;
            return ul.children.item(1).innerText == "Banana" || ul.children.item(1).innerText == "banana" 
          })
          BlocklyTest.expect(2, "There are at least 4 items", ul, (ul) => {
            return ul.children.length >= 4
          })
        });
      </script>
      <p>
        This exercise introduces some the HTML/DOM blocks to add elements and set their contents.
      </p>
        <ol>
            <li>Let's start with an html list with a single apple in the "Static html" 
                <ol>
                    <li>Note the list has an id ("list") so that we can refer to it from blockly</li>
                    <li>for example: <code id="start_exercise_add_fruit">&lt;ul id="list"&gt;&lt;li&gt;Apple&lt;/li&gt;&lt;/ul&gt;</code></li>
                </ol>
            <li>Add one more fruit dynamically</li>
                <ol>
                    <li>Add an "at the start" block</li>
                    <li>Inside this block, add a "find the element using css selector" block using the id for the ul element (<code>#list</code>)</li>
                    <li>Inside this block, add a "create a new ... element" block and select "&lt;li&gt;"</li>
                    <li>Inside this block, add a "set the text content" block and set the value to "Banana"</li>
                    <li id="exercise_add_fruit_1">Click "run" to check the output looks like
                        <ul style="background-color: azure;">
                            <li>Apple</li>
                            <li>Banana</li>
                        </ul>
                    </li>
                </ol>
            </li>
            <li id="exercise_add_fruit_2">Repeat the process above to add two more of your favourite fruit (hint: you can add multiple "create a new ... element" blocks one after the other)</li> 
        </ol>
      </div>
      <div class="exercise" id="exercise_list_links">
      <h2>Creating html dynamically: lists of links</h2>
      <script>
        BlocklyTest.registerTest("exercise_list_links", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let startLiCount = 0;
          if (ul) {
            startLiCount = ul.children.length;
          }
          BlocklyTest.expect(1, "There are 3 links with href attributes", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return startLiCount != 3 && lis.length == 3 && lis.every((li) => li.querySelector("a[href]") && li.querySelector("a[href]").innerText);
          })
        });
      </script>
      <p>
        This exercise consolidates the use of the blocks we learned about in the previous exercises.
      </p>
        <ol>
            <li>Start with an empty unordered html list (<code id="start_exercise_list_links">&lt;ul id="list"&gt;&lt;/ul&gt;</code>) in the static html.
            <li>Dynamically add your favourite links to the html list</li>
                <ol>
                    <li>Find the urls of your three favourite websites (they look something like: <code>http://www.codeyourfuture.io</code>)</li>
                    <li>Use the blocks we have seen so far ("at the start", "find the element using css selector", "create a new ... element", "set the attribute", "set the text content")</li>
                    <li>Hint: you will need to create an <code>&lt;a&gt;</code> inside each block to create an <code>&lt;li&gt;</code></li>
                    <li id="exercise_list_links_1">Click "run" to check the output looks something like
                        <ul style="background-color: azure;">
                            <li><a href="http://www.codeyourfuture.io">Code your future</a></li>
                            <li><a href="http://www.google.com">Google</a></li>
                            <li><a href="http://news.bbc.co.uk">BBC News</a></li>
                        </ul>
                    </li>
                </ol>
            </li> 
        </ol>
      </div>
      <div class="exercise" id="exercise_button_add">
      <h2>Buttons and clicks: A button to add apples</h2>
      <script>
        BlocklyTest.registerTest("exercise_button_add", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let button = BlocklyTest.findElement(["#button", "button"]);

          BlocklyTest.expectAfterClick(1, "The button adds an apple", button, 
          () => {
            let count = ul ? ul.children.length : 0;
            return count;
          },
          (countBefore, countAfter) => {
            let addsExactlyOneChild = countBefore + 1 == countAfter
            var lastLi = ul.lastChild;
            return (addsExactlyOneChild && lastLi.innerText.toLowerCase() == "apple");
          });

          BlocklyTest.expect(2, "There are at least 3 apples and 3 bananas", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return (lis.filter((li) => li.innerText.toLowerCase() == "apple").length >= 3 
                && lis.filter((li) => li.innerText.toLowerCase() == "banana").length >= 3);
          });
        });
      </script>
      <p>
        A lot of javascript is run responsively to the user interacting with the page (clicking, scrolling, etc.). Let's make it so every time we (as a "user") click on an "add an apple" button, it adds an apple to the list.
      </p>
        <ol>
            <li>Start with an empty unordered html list (<code>&lt;ul&gt;</code>) and a button to add apples to the list (<code>&lt;button&gt;</code>) in the static html.
                <ol>
                    <li>note there is with an id for each element ("list") and ("button") so that we can refer to them from Blockly</li>
                    <li>for example: <code id="start_exercise_button_add">&lt;ul id="list"&gt;&lt;/ul&gt;&lt;button id="button"&gt;add an apple&lt;/button&gt;</code></li>
                </ol>
            <li>When we click on the "add an apple" button, let's add an apple to the list</li>
                <ol>
                    <li>Add a "when the element with id ... is clicked" block (it doesn't need to be connected to any other blocks)</li>
                    <li id="exercise_button_add_1">Inside this block, add the blocks necessary to find the "list" element, create a new "li" element and set the content to "apple" (you know how to do this from previous exercises)</li>
                </ol>
            </li> 
            <li id="exercise_button_add_2">Can you add a second button (in the static html) that adds bananas when clicked? Check that you (as the user) can now add both apples and bananas depending on which button you click. Click "run" and press the buttons to add at least 3 of each fruit, so the output looks something like
                <ul style="background-color: azure;">
                    <li>Apple</li>
                    <li>Banana</li>
                    <li>Apple</li>
                    <li>Apple</li>
                    <li>Banana</li>
                    <li>Banana</li>
                </ul>
            </li>
        </ol>
      </div>
      <div class="exercise" id="exercise_button_consolidation">
      <h2>Buttons and clicks consolidation</h2>
      <p>
        Anything that we could do previously as soon as run is pressed, we can now do as a response to clicking.
      </p>
        <ol>
            <li id="exercise_button_consolidation_1">Can you create two buttons that respectively change an html list to "day mode" (dark text on a light background) and "night mode" (light text on a dark background)</li>
            <li id="exercise_button_consolidation_2">Can you create a button that changes colour when it is clicked (note: in the interest of simplifying these exercises, this is one block more complicated than it would be in regular javascript)?
            <li id="exercise_button_consolidation_3">Can you create an image that changes when it is clicked?</li>
        </ol>
      </div>
      <div class="exercise" id="exercise_lists">
      <h2>Lists and html lists</h2>
      <script>
        BlocklyTest.registerTest("exercise_lists", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = BlocklyTest.findArrayValues(); // first of the arrays is the one we want

          BlocklyTest.expect(1, "All the elements in the list are in the html list", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == list.length && lis.every((li, index) => li.innerText == list[index]);
          });
        });
      </script>
      <p>In this series of exercises, we have so far created unordered html lists (<code>&lt;ul&gt;</code>) containing html list items (<code>&lt;li&gt;</code>). 
        We will now introduce a different kind of list, that is used for representing a list of data (typically numbers or texts) in javascript. Such a list can be created and used from the Blockly "Lists" menu but does not automatically convert to an html list.
        This kind of list is not often used in javascript programming, but will simplify the Blockly code we need to write for the upcoming series of exercises.
      </p>
      <ol>
          <li>Start with an empty unordered html list with the id "list" (<code id="start_exercise_list">&lt;ul id="list"&gt;&lt;/ul&gt;</code>) in the static html.</li>
          <li>In Blockly, add an "at the start" block"</li>
          <li>We'll now create a list of fruit and assign it to a variable <ol>
              <li>From the "Lists" menu, add a "Set ... to, create list with" block to the "at the start" block</li>
              <li>Rename the variable "item" to "fruits"</li>
              <li>Add at least 3 fruit text values to this list</li>
              <li>Note: You can click on the gear menu to add and remove slots for values</li>
          </ol></li>
          <li>Let's do the first steps of converting this list to an html list<ol>
              <li>Add the blocks necessary to add an html list item (<code>&lt;li&gt;</code>) with the content "apple" to the html list with id "list" (you know how to do this from previous exercises)</li>
              <li>Remove the "apple" text value block and replace it with a "get current item from list" block</li>
              <li>Select the "fruits" variable in the dropdown</li>
              <li>This kind of list has a current item. As you can see, the current item starts off being the first item in the list</li>
          </ol></li>
          <li>Changing the current item...<ol>
              <li>Before the "create a new ... element" block, insert a "select next item for list" block</li>
              <li>Again, select the "fruits" variable in the dropdown (you will have to do this every time)</li>
              <li>As you can see by pressing "run", the current item has changed and is now the second item in the list</li>
              <li>What do you think will happen if you change "next" to "last" (try it out to find out if you were right)</li>
              <li>What do you think will happen if you change "next" to "previous" (try it out to find out if you were right)</li>
          </ol></li>
          <li id="exercise_lists_1">Alternate "create a new ... element" and "select next item for list" blocks to display all the items in your fruits list</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_list_loops">
      <h2>Lists and loops</h2>
      <script>
        BlocklyTest.registerTest("exercise_list_loops", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = BlocklyTest.findArrayValues(); // first of the arrays is the one we want

          BlocklyTest.expect(1, "All the elements in the list are in the html list. There are at least 4 elements", ul, (ul) => {
            var lis = Array.from(ul.querySelectorAll("li"));
            return lis.length>=4 && lis.length == list.length && lis.every((li, index) => li.innerText == list[index]);
          });
        });
      </script>
      <p>So far we have worked with a list where we knew exactly the number of items there would be. But what happens if that number is changeable?</p>
      <ol>
          <li>Starting with recreating the result of the previous exercise, then add a new fruit item to your list. Does it display if you press "run"?</li>
          <li>Currently, you have just as many "create a new ... element" blocks as there are items in the list, instead, we are going to use the "list ... has current element" block, combined with a loop</li>
          <li>If you use enough "select next item for list" blocks, you run off the end and the current item no longer exists. In this case, "list ... has current element" returns the value false</li>
          <li>We can use this as the condition in a "repeat while" loop <ol>
              <li>Add a "repeat while" block just before your first "create a new ... element"</li>
              <li>Set the condition value "list ... has current element" (remember to select "fruits" in the dropdown)</li>
              <li>Inside the loop, add the blocks to create a new <code>&lt;li&gt;</code> and set the contents to "get current item from list"</li>
              <li>Inside the loop, add the block to select the next item in the list</li>
              <li id="exercise_list_loops_1">Check that all your fruit are now displaying</li>
              <li>Check that this is still true if you add and remove fruit from the fruits list</li>
          </ol></li>
      </ol>
      </div>
      <div class="exercise" id="exercise_list_loops_more">
      <h2>Loops, and lists: more fun with fruit</h2>
      <script>
        BlocklyTest.registerTest("exercise_list_loops_more", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = BlocklyTest.findArrayValues(); // first of the arrays is the one we want
          let listReversed = list.slice().reverse();
          let listApplesFirst = [];
          let lastAppleIndex = -1;
          list.filter((value, index) => {
            if (value.toLowerCase()=="apple") {
              lastAppleIndex = index;
              return true;
            }
            return false;
          }).forEach((apple) => listApplesFirst.push(apple));
          if (lastAppleIndex == listApplesFirst.length-1) {
            // there isn't an out of order apple -> force to fail
            listApplesFirst.push("");
          }
          list.filter((value) => value.toLowerCase()!="apple").forEach((notApple) => listApplesFirst.push(notApple));

          BlocklyTest.expect(1, "All the elements in the list are in the html list in reverse order", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == listReversed.length && lis.every((li, index) => li.innerText == listReversed[index]);
          });

          BlocklyTest.expect(2, "All the elements in the list are in the html list with apples first", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == listApplesFirst.length && lis.every((li, index) => li.innerText == listApplesFirst[index]);
          });
        });
      </script>
      <p>Although we can convert a list directly into an html list, we can also generate more than one output with the same list.</p>
      <ol>
          <li id="exercise_list_loops_more_1">Using the blocks we have seen so far (with slight modifications), create an html list with the fruit in reverse order</li>
          <li id="exercise_list_loops_more_2">Using the blocks we have seen so far and the if block, create an html list of the fruit with all the apples first (they are my favourite) and the other fruit after (add several apples at the beginning, middle and end of your list to check it works)</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_train_stops">
      <h2>Listing train stops</h2>
      <script>
        BlocklyTest.registerTest("exercise_train_stops", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let list = ["Glasgow Queen Street", "Falkirk High", "Haymarket", "Edinburgh Waverly"];
          let reversedList = list.slice().reverse();
          let thereAndBackList = list.slice();
          thereAndBackList.pop();
          thereAndBackList = thereAndBackList.concat(reversedList); 
          
          BlocklyTest.expect(1, "Stops are in order from Glasgow to Edinburgh", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == list.length && lis.every((li, index) => li.innerText == list[index]);
          });

          BlocklyTest.expect(2, "Stops are in order from Edinburgh to Glasgow", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == reversedList.length && lis.every((li, index) => li.innerText == reversedList[index]);
          });

          BlocklyTest.expect(3, "Stops are in order from Glasgow to Edinburgh and back. Only show Edinburgh once", ul, (ul) => {
            let lis = Array.from(ul.querySelectorAll("li"));
            return lis.length == thereAndBackList.length && lis.every((li, index) => li.innerText == thereAndBackList[index]);
          });
        });
      </script>
      <p>The fast train between Glasgow and Edinburgh stops at Falkirk High and Haymarket. Let's display some html lists of stops</p>
      <ol>
          <li>Create a list named "stops" to represent all the stops, with the values: Glasgow Queen Street, Falkirk High, Haymarket, Edinburgh Waverly. Do the following tasks without changing the values in this list</li>
          <li id="exercise_train_stops_1">Display the html list of all the stops between Glasgow and Edinburgh
              <ul style="background-color: azure;">
                <li>Glasgow Queen Street</li>
                <li>Falkirk High</li>
                <li>Haymarket</li>
                <li>Edinburgh Waverly</li>
              </ul>
          </li>
          <li id="exercise_train_stops_2">Display the html list of all the stops between Edinburgh and Glasgow
              <ul style="background-color: azure;">
                <li>Edinburgh Waverly</li>
                <li>Haymarket</li>
                <li>Falkirk High</li>
                <li>Glasgow Queen Street</li>
              </ul>
          </li>
          <li id="exercise_train_stops_3">Display the html list of all the stops on a return journey from Glasgow to Edinburgh and back
              <ul style="background-color: azure;">
                <li>Glasgow Queen Street</li>
                <li>Falkirk High</li>
                <li>Haymarket</li>
                <li>Edinburgh Waverly</li>
                <li>Haymarket</li>
                <li>Falkirk High</li>
                <li>Glasgow Queen Street</li>
              </ul>
          </li>
      </ol>
      </div>
      <div class="exercise" id="exercise_list_consolidation">
      <h2>List consolidation</h2>
      <p>Repeat the exercise to show a list of your favourite links. Use a loop so that there are only two "create a ... element" blocks (one for the &lt;li&gt;, one for the &lt;a&gt;). Outline what your solution needs to look like, and implement it step by step, pressing "run" at each iteration to check your work</p>
      </div>
      <div class="exercise" id="exercise_lists_buttons">
      <h2>Lists and buttons</h2>
      <script>
        BlocklyTest.registerTest("exercise_lists_buttons", () => {
          let ul = BlocklyTest.findElement(["#list", "ul", "ol"]);
          let button = BlocklyTest.findElement(["#button", "button"]);
          let listToBeRevealed = BlocklyTest.findArrayValues(); // first of the arrays is the one we want

          BlocklyTest.expectAfterClick(1, "Each press of the button reveals a fruit", button, 
          () => {
            let count = ul ? ul.children.length : 0;
            return count;
          },
          (countBefore, countAfter) => {
            let addsExactlyOneChild = countBefore + 1 == countAfter;
            if (addsExactlyOneChild) {
              let lastLi = ul.lastChild;
              if (lastLi && lastLi.innerText == listToBeRevealed[0]) {
                listToBeRevealed.shift();
              }
            }
            return listToBeRevealed.length == 0;
          });
        });
      </script>
      <p>One way to do something with all the items in a list is to use a loop. Instead, let's look at each item one by one as the user clicks on a button</p>
      <ol>
          <li>Create an empty unordered html list (as usual) and a "reveal next fruit" button (<code id="start_exercise_lists_buttons">&lt;ul id="list"&gt;&lt;/ul&gt;&lt;button id="button"&gt;reveal next fruit&lt;/button&gt;</code>)</li>
          <li>In blockly, create a list of your favourite fruit in an "at the start" block</li>
          <li id="exercise_lists_buttons_1">Each time the user clicks on the button, the next fruit should be added to the list (yes, you can do things with the list of fruit from the blocks in a "when the element with id ... is clicked")</li>
          <li>As a stretch goal, when there are no more fruits to be revealed, clicking the button should do nothing - or the button should no longer be visible</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_story_book">
      <h2>Create a story book</h2>
      <p>The great thing about story books is that you never know what will happen when you turn the page!</p>
      <ol>
          <li>Create a simple story book "experience" where you click on a button and something new happens</li>
          <li>Make the story a bit more complicated. Maybe the user has choices? Maybe an image appears at the end?</li>
      </ol>
      </div>
      <div class="exercise" id="exercise_image_carousel">
      <h2>Build an image carousel</h2>
      <p>
        An image carousel has an image with two buttons ("previous" and "next")
        that allow the user to cycle through a list of images.
      </p>
      <ul>
        <li>
          A list of at least 3 image urls should be defined in blockly (you can
          use public urls from stock photograph websites, or copy the image link from a google search result)
        </li>
        <li>
          Clicking on the "previous" button should show the previous image
        </li>
        <li>Clicking on the "next" button should show the next image</li>
        <li>
          Stretch goal: if clicking next or previous would take us before the
          first item or after the last, cycle round to the last/first item
          instead
        </li>
      </ul>
      <p>
        You should first break down this problem into steps, then outline how
        each step will probably be solved (and how you can test that it does what you think it does), before creating any blocks
      </p>
    </div>
    <div class="exercise" id="exercise_projects">
      <h2>Some more "projects"</h2>
      <p>Here are some additional ideas of projects that can be accomplished with the current blocks 
        (some newer blocks haven't been properly introduced yet) and might be suitable/adaptable as 
        landing page enhancements. They all fit generally into the "add some button or event handlers 
        that add or modify some html" category.
      </p>
      <ul>
        <li>Shopping cart<ol>
          <li>Create a list of products.</li>
          <li>Display each product in an html list with a "add to shopping cart" button next to it</li>
          <li>When the button is clicked, add the product to a separate html list that represents the current shopping cart</li>
        </ol></li>
        <li>List with a hidden 2nd level<ol>
          <li>Create an html list with a second list inside each li (maybe a list of folders and the files in each folder?)</li>
          <li>Hide the inner lists</li>
          <li>Clicking the first level item toggles the visibility of the inner list (if it's hidden, show it, if it's visible, hide it)</li>
        </ol></li>
        <li>Paginated list<ol>
          <li>Create a list of 9 items (maybe there are 9 results of a search?)</li>
          <li>Display the first 3 elements and buttons below marked "previous" and "next"</li>
          <li>Clicking next should show the next 3 elements (if there are any left)</li>
          <li>Clicking next should show the next 3 elements (if there are any)</li>
          <li>Stretch goal: don't show previous/next if there are no previous/next items</li>
          <li>Stretch goal: what happens if there are 8 items in the list</li>
          <li>Stretch goal: display the current page/total (e.g. "page 2/3") (note this probably requires string concatenation operations in the toolbox that aren't there yet)</li>
        </ol></li>
        <li>Hamburger menu<ol>
          <li>Can be vaguely inspired by e.g. https://dev.to/devggaurav/let-s-build-a-responsive-navbar-and-hamburger-menu-using-html-css-and-javascript-4gci</li>
          <li>Display an ul of nav links as a "closed" hamburger</li>
          <li>Clicking on the hamburger makes the ul visible</li>
          <li>Clicking on the hamburger transforms the hamburger into an X</li>
          <li>Clicking on the X makes the ul invisible (and shows the hamburger)</li>
          <li>Clicking on any link makes the ul invisible (and shows the hamburger)</li>
        </ol></li>
        <li>Create a check list<ol>
          <li>Display a list of todo items</li>
          <li>When each item is clicked, mark it in some way (strike through, invisible)</li>
          <li>Note: this is basically a variant of the shopping cart</li>
        </ol></li>
        <li>Create a todo list<ol>
          <li>Display an input and an "add todo" button (currently the input and means of accessing the input don't exist, so would have to add some blocks)</li>
          <li>When the "add todo" is clicked, add the item to an html list</li>
          <li>Stretch goal: combine with the exercise above</li>
        </ol></li>
      </ul>
    </div>
    <xml id="toolbox" style="display: none">
      <category name="Loops" colour="120">
        <block type="controls_whileUntil"></block>
        <block type="controls_for"></block>
      </category>
      <category name="Logic" colour="210">
        <block type="controls_if"></block>
        <block type="logic_negate"></block>
        <block type="logic_compare"></block>
      </category>
      <category name="Values" colour='%{BKY_TEXTS_HUE}'>
        <block type="math_number"></block>
        <block type="text"></block>
        <block type="colour_picker"></block>
        <block type="logic_boolean"></block>
      </category>
      <category name="Html" colour="%{BKY_COLOUR_HUE}">
        <block type="on_start"></block>
        <block type="element_clicked"></block>
        <block type="with_element_by_selector"></block>
        <block type="add_element"></block>
        <block type="set_content">
          <value name="VALUE">
            <shadow type="text"> </shadow>
          </value>
        </block>
        <block type="set_attribute"></block>
        <block type="remove_contents"></block>
        <block type="element_clicked_current"></block>
        <block type="with_elements_by_selector"></block>
      </category>
      <category name="Lists" colour="%{BKY_LISTS_HUE}"" >
        <block type="variables_set">
          <field name="VAR">list</field>
          <value name="VALUE">
            <block type="linked_lists_create_with"> </block>
          </value>
        </block>
        <block type="linked_lists_get_current">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_set_current">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_has_current">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_has_next">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
        <block type="linked_lists_has_previous">
          <value name="VALUE">
            <block type="variables_get">
                <field name="VAR">list</field>
            </block>
          </value>
        </block>
      </category>
      <category name="Variables" colour="330" custom="VARIABLE"></category>
      <category name="Functions" colour="290" custom="PROCEDURE"></category>
    </xml>
    <script src="exercises.js"></script>
  </body>
</html>
